/*
有一个长为n的数列a0, a1, ......, a(n-1)。请求出这个序列中最长的上升子序列的长度。上升子序列指的是对于任意的i<j都满足ai<aj的子序列，该问题被
称为最长上升子序列（LIS，Longest Increasing Subsequence）的著名问题。

举个栗子：给你一个序列为（1，5 ，2，6，9，10，3，15），那么它的最长上升子序列为：（1，2，6，9，10，15）

这个问题用DP的思想很容易解决。
*/

/*
首先我们来讲解一下他的递推关系式：
定义dp[ i ] 为：以 ai 为末尾的最长上升子序列的长度。
那么dp[ i ] 包含什么呢？

情况1`: 只包含它自己，也就是说它前面的元素全部都比他大；举个栗子：一个序列（7， 9， 6， 10， 7， 1， 3）分别为 （a1, a2, a3, a4, a5, a6,
 a7）那么dp[ 6 ] == 1;

情况2`：为了保证上升子序列尽可能的长，那么就有 dp[ i ]  尽可能的大， 但是再保证 dp[ i ] 尽可能大的基础上，还必须满足序列的上升；
所以呢 dp[ i ] = max ( 1 , dp[ j ] + 1 ) {  j < i && aj < ai   } 。这里的1就是当 ai 前面的数都比他大的时候，他自己为一个子序列；
dp[ j ] + 1 指的是： 当第 i 个数前面有一个 第 j 个数满足 aj  <  ai  并且 j < i 这时候就说明 ai 元素可以承接在 aj 元素后面来尽可能的增加子序列的长度。

将 j 从 1 遍历到 i - 1  ，在这之间，找出尽可能大的dp[ i ]即为最长上升子序列的长度(提示下 dp[n] 不一定是最长的子序列，n为数列中数的个数，
例如序列 [ 2, 3, 4, 5, 1 ]，dp[5] = 1(由子序列[1]构成)，然而 dp[4] = 4(由子序列 [2,3,4,5] 构成) )

上面说的还是有点笼统， 那么再举个栗子吧：
还是用刚才的序列：（7， 9， 6， 10， 7， 1， 3）分别为 （a1, a2, a3, a4, a5, a6, a7）

最开始a1 = 7,  令dp[ 1 ] = 1；
然后看下一个元素 a2 = 9, 令dp[ 2 ] = 1, 那么需要检查 i 前面是否有比他小的 因为 a1 < a2 而且 dp[ 1 ] + 1 > dp[ 2 ], 
所以dp[ 2 ] = dp[ 1 ] + 1 == 2;
然后再看下一个元素 a3 = 6, 令 dp[ 3 ] = 1, 那么需要检查前面的元素 a1  与 a2 是否有比他小的， 一看没有，辣么 到目前为止，子序列就是他自己。
然后再看一下下一个元素 a4 = 10; 令 dp[ 4 ] = 1;  那么需要依次检查前面的元素 a1  与 a2 与 a3 是否有比他小的 , 一看a1比它小，而且呢，
dp[ 1 ] + 1 > dp[ 4 ] 所以呢 dp[ 4 ] = dp[ 1 ] + 1 == 2, 说明此时 a1 与 a4 可以构成一个长度为 2 的上升子序列，
再来看看还可不可以构成更长的子序列呢，所以咱们再来看看 a2 , a2 < a4 而且呢 dp[ 2 ] + 1 == 3 > dp[ 4 ] == 2  
所以呢dp[ 4 ] = dp[ 2 ] + 1 == 3,  即将a4承接在a2后面比承接在a1后更好，承接在a2后面的序列为：a1 a2 a4 ，构成一个长度为 3 的上升子序列;
 然后再来看 a3 , a3 < a4 但是可惜的是 d[ 3 ] + 1 == 2  < dp[ 4 ] == 3 ,  所以呢就不能把a4加在a3的后面 。
然后就是重复上述过程，找到最大的dp [ i ] 那么这个数就是最长上升子序列。
*/

#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int main()
{
    int arr[500], n, dp[500], ans = -1;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d", &arr[i]); //不建议用cin cout 他们执行的时候还得先分析数据类型，耗时比 scanf printf  多好多，很多题目就因为这个地方而超时，导致比赛的时候罚时
    /* 求解最长子序列的个数的核心代码 */
    /* ********************************************** */
    for(int i = 1; i <= n; i++){
        dp[i] = 1; //初始化
        for(int j = 1; j < i; j++){
            if(arr[j] < arr[i]) // 如果求最大下降子序列则反之
                dp[i] = max(dp[i], dp[j] + 1);
        }
        ans = max(dp[i], ans);
    }
    /* ********************************************** */
 
    printf("最长子序列的个数为： %d", ans);
    return 0;
}
/*
样例：
7
7 9 6 10 7 1 3
最长子序列的个数为： 3
*/


/*
LIS的nlogn的优化：
LIS的优化说白了其实是贪心算法，比如说让你求一个最长上升子序列把，一起走一遍。

比如说（4, 2, 3, 1, 2，3，5）这个序列，求他的最长上升子序列，那么来看，如果求最长的上升序列，那么按照贪心，应该最可能的让该序列的元素整体变小，以便可以加入更多的元素。
现在开辟一个新的数组，arr[ 10 ]， { .......} --> 这个是他的空间 ，
现在开始模拟贪心算法求解最长上升子序列，第一个数是4，先加进去，那么为{ 4 }
再来看下一个数2，它比4小，所以如果他与4替换是不是可以让目前子序列（他这一个元素组成的子序列）变得更小，更方便以后元素的加入呢？
是的 。同时还保证了序列的长度不变，所以将大的数替换成小的是可以在保证序列长度不变的前提下是整体序列更小，更容易加入元素 。
所以现在为{ 2 } 再来看他的下一个元素3，他要比2大，所以呢加在他的后面，{ 2, 3}
再看下一个元素是1，它比3要小，所以呢为了保证子序列整体尽可能的小（以便可以加入更多的元素），从目前的序列中查找出第一个比他大的数替换掉，
那么就变成了{ 1， 3}，继续。。 下一个数是2，那么序列变为{ 1，2}，再下一个数为3，那么序列为{1，2，3}，
在下一个数为5，那么序列为{1，2，3，5}，完。 
目前序列里又4个元素，所以他的最长子序列的个数为4，但是这个序列是一个伪序列，
里面的元素，并不是真正的最长上升子序列，而仅仅和最长上升子序列的个数一样。因为查找的时候用的二分查找，所以时间复杂度为o（nlogn）。

*/

#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int main()
{
    int arr[500], n, dp[500], ans = -1;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d", &arr[i]);
    /* 求解最长子序列的个数的核心代码 */
    /* ********************************************** */
    int k = 1;
    dp[k] = arr[1];
    for(int i = 2; i <= n; i++){
        if(dp[k] < arr[i]) dp[++k] = arr[i]; //如果比最后一个元素大，那么就添加再最后末尾处
        else *(lower_bound(dp + 1, dp + 1 + k, arr[i])) = arr[i]; //如果比最后一个元素小，那么就替换该序列第一个比他大的数；
    }
    /* ********************************************** */
 
    printf("最长子序列的个数为： %d", k);
    return 0;
}

//O(n^2)算法标记路径，只需要使用一个记录前驱的数组 pre 即可。

/*
nlogn 算法的路径标记：
        首先要明确的是通过nlogn算法得到的最后的序列是乱的，只有序列的长度是有价值的，所以最后的序列并不是路径。
        不过我们可以对更新过程中的实际位置来进行标记，最后得到想要的路径。直接举例子吧。用mp数组记录在序列中的位置。
        具体思路类似把整个数组中出现的数字分级形成类似树的结构。再用优先级反推出前驱。
*/

#include<bits/stdc++.h>
#define up(i, x, y) for(ll i = x; i <= y; i++)
#define down(i, x, y) for(ll i = x; i >= y; i--)
#define bug printf("***************************\n")
#define debug(x) cout<<#x"=["<<x<<"]" <<endl
#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define lk k<<1
#define rk k<<1|1
typedef long long ll;
typedef unsigned long long ull;
const double eps = 1e-8;
const ll mod = 1e9 + 7;
const ll maxn = 1e5 + 7;
const double pi = acos(-1);
const ll inf = 0x3f3f3f3f;
const ll INF = 0x3f3f3f3f3f3f3f3fLL;
using namespace std;
 
int top, ans, len, x, y;
int st[maxn], mp[maxn], path[maxn];
 
struct node
{
	int w, v, id;
}a[maxn];
 
bool cmp(node a, node b)
{
	if(a.v != b.v)
		return a.v > b.v;
	return a.w < b.w;
}
 
int main(int argc, char const *argv[])
{
	while(cin >> x >> y)
	{
		a[++len].w = x;
		a[len].v = y;
		a[len].id = len;
	}
 
	sort(a + 1, a + 1 + len, cmp);
 
	top = 0;
	st[++top] = a[1].w; // 将第一个元素压入栈中
	mp[a[1].id] = 1;    // 确定第一个元素的位置
	for(int i = 2; i <= len; ++i)
	{
		if(a[i].w > st[top]) // 如果当前的值大于栈顶的元素
		{
			st[++top] = a[i].w; // 加入栈中
			mp[a[i].id] = top;  // 标记在栈中的实际位置，方便后续查找路径
		}
		else
		{
			int l = 1, r = top;  // 二分查找第一个比 a[i].w 大的元素，来进行替换
			while(l <= r)
			{
				int mid = (l + r) >> 1;
				if(st[mid] < a[i].w)
				{
					l = mid + 1;
				}
				else
				{
					r = mid - 1;
				}
			}
			st[l] = a[i].w; // 替换
			mp[a[i].id] = l;  // 记录实际位置在栈中的
		}
	}
 
	ans = top;
	for(int i = len; i >= 1; i--)
	{
		if(mp[a[i].id] == top)      //根据位置来找出路径
			path[top--] = a[i].id; 
	}
 
	printf("%d\n", ans);
	for(int i = 1; i <= ans; i++)
	{
		printf("%d\n", path[i]);
	}
 
	return 0;
}